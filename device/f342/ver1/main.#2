
    ////////////////////////////////////////////////////////////////////
//
// <NAME PROJECT WITH MORE INFO>
// 
// Name:		Hatab Samwill
// Version:		1.0 
// Project started:	16.03.2013: 
// Project ended::
// 
// version 1 - 
// build: 160313
// 
// EEPROM 24c64 - 64Kbit (8 Kbytes)
// OSCILLATOR 24Mhz on p0.2, p0.3
//
// Плавает 1-2 мм на 20 см
// Нет "болтанки" и дребезгов
//
#define VERSION2 	// Версия платы: 
					// ------------
					// 1.0 - Первый блин
					// 2.0 - 
					// 3.0 - 
					// 3.1 - 
					// 3.2 - 
#define ALGO3
#define DEFAULT_DISCRET		100;
#define EEPROM_24C128
#define REVISION_VER_DIGIT1 0x01 // версия прошивки
#define REVISION_VER_DIGIT2 0x00

#define EncA    2
#define EncB    3
#define EncSw   6
#define EncIN   P0
#define EncPort P0
#define EncMask ((1<<EncB)|(1<<EncA)|(1<<EncSw))

#include "compiler_defs.h"
#include "C8051f340_defs.h"
//#include "C8051f340.h"
#include "USB_API.h"
#include <math.h>
#include <string.h>

#define INTERRUPT_USBXpress 17
//#define _GENERATOR_MODE_ON_OFF_ ~state
//////////////////////////////////////////////////////
///
///            PORT PINS CONFIGURATIONS (Defines)
/// 
//////////////////////////////////////////////////////
// 
// PINS
// 
sbit EEPROM_SDA 			= P0^0;
sbit EEPROM_SCL 			= P0^1;

#ifdef VERSION1
sbit KEY1 					= P2^5;
sbit KEY2 					= P2^6;
sbit KEY3 					= P2^7;
sbit KEY4 					= P0^6;

sbit SEGMENT_A				= P0^7;
sbit SEGMENT_B				= P1^0;
sbit SEGMENT_C				= P1^1;
sbit SEGMENT_D				= P1^2;
sbit SEGMENT_E				= P1^3;
sbit SEGMENT_F				= P1^4;
sbit SEGMENT_G				= P1^5;
sbit SEGMENT_POINT			= P1^6;

sbit LED1					= P1^7;
sbit LED2					= P2^0;
sbit LED3					= P2^1;
sbit LED4					= P2^4;
sbit LED5					= P2^3;
sbit LED6					= P2^2;

sbit EXT_INT0				= P0^4;
sbit EXT_INT1				= P0^5;
#endif

#ifdef VERSION2
sbit KEY1 					= P0^4;
sbit KEY2 					= P2^5;
sbit KEY3 					= P0^6;
sbit KEY4 					= P0^5;

sbit SEGMENT_A				= P1^0;
sbit SEGMENT_B				= P1^1;
sbit SEGMENT_C				= P1^2;
sbit SEGMENT_D				= P1^3;
sbit SEGMENT_E				= P1^4;
sbit SEGMENT_F				= P1^6;
sbit SEGMENT_G				= P1^5;
sbit SEGMENT_POINT			= P0^7;

sbit LED1					= P1^7;
sbit LED2					= P2^0;
sbit LED3					= P2^1;
sbit LED4					= P2^2;
sbit LED5					= P2^3;
sbit LED6					= P2^4;

sbit EXT_INT0				= P0^2;
sbit EXT_INT1				= P0^3;
#endif

//
// Адреса области EEPROM
//
#define EEPROM_TEST_ADDR1 					0x00
#define EEPROM_TEST_ADDR2 					0x01
#define EEPROM_CONST_ADDR					0x02
#define EEPROM_RESET_COUNTER_ADDR			0x03
#define EEPROM_COUNTER_ADDR_LOW				0x04
#define EEPROM_COUNTER_ADDR_HIGH			0x05
#define EEPROM_LCDMODE_ADDR					0x10
#define EEPROM_DISCRET_ADDR_LOW				0x20
#define EEPROM_DISCRET_ADDR_HIGH			0x21

// Device addresses (7 bits, lsb is a don't care)
#define  SYSCLK         12000000
#define  SMB_FREQUENCY  40000          // Target SCL clock rate
                                       // This example supports between 10kHz
                                       // and 100kHz

#define  WRITE          0x00           // SMBus WRITE command
#define  READ           0x01           // SMBus READ command
#define  EEPROM_ADDR    0xA0           // Device address for slave target
                                       // Note: This address is specified
                                       // in the Microchip 24LC02B
                                       // datasheet.
#define  TARGET			0xA0           // Target SMBus slave address


// SMBus Buffer Size
#define  SMB_BUFF_SIZE  0x08           // Defines the maximum number of bytes
                                       // that can be sent or received in a
                                      // single transfer
// Status vector - top 4 bits only
#define  SMB_MTSTA      0xE0           // (MT) start transmitted
#define  SMB_MTDB       0xC0           // (MT) data byte transmitted
#define  SMB_MRDB       0x80           // (MR) data byte received
//
// ..
#define TIMER0_RELOAD_HIGH 0xF8
#define TIMER0_RELOAD_LOW  0xF8

//--------------------------TIMER DEFINITIONS ------
#define TIMER_PRESCALER           32  //48  // Based on Timer CKCON settings

#define TIMER_TICKS_PER_MS  SYSCLK/TIMER_PRESCALER/1500 //1000

#define AUX1     TIMER_TICKS_PER_MS
#define AUX2     -AUX1

#define READ_TEMP_COUNT 255
#define Timer0_Rate 10
#define Timer0_RateEncoder 5
//
// SYSCLK/SMB_FREQUENCY/4/3) < 255)
//---------------------------------------------------------

// Prototypes
//
void Initialize(void);
void Timer0_Init(void);
void Timer1_Init(void);
void Timer3_Init(void);
void Timer3_ISR(void);
void Timer0_ISR(void);
void OSCILLATOR_Init (void);
void Ext_Interrupt_Init (void);
void Port_Init(void);
void SMBus_Init (void);
void SMBus_ISR(void);
//
// Функции контроллера юзер интерфейсные
void EEPROM_ByteWrite(U16 addr, unsigned char dat);
unsigned char EEPROM_ByteRead(U16 addr);
void LedsSwitchOff(void);
void OutSymbol(unsigned char , unsigned char);
void WriteCounterToEEprom(void);
void WriteDiscretToEEprom(void);
void LcdOutputLine(unsigned char);
void EncoderScan2(void);
void EncoderScan3(void);
void EncoderScan4(void);
void EncoderScan5(void);

//
void ResetCounterToOutputBuffer(void);
void OutputBufferToResetCounter(void);
//
void Del_10mks(void);
void Del_25ms(void);
void Del_100ms(void);
void Del_500mks(void);
void Del_10ms(void);
void Del(int);
////////////////////////////
////////////////////////////
// GLOBAL ПЕРЕМЕННЫЕ !!!
////////////////////////////
unsigned char Flag = 0;
unsigned long Counter = 0, TempCounter, Discret ;
bit Flag1 = 1;
bit FlagPoint = 0;
bit KeyFlag1 = 0;
bit KeyFlag2 = 0;
bit KeyFlag3 = 0;
bit KeyFlag4 = 0;
bit LongKeyFlag = 0;
unsigned int LongKeyFlagCounter = 0;
unsigned char LcdMode = 0;
//unsigned int Discret = 0;
unsigned char EncData, EncState, OldState, EncTemp;
unsigned char EncN = 0, EncOld[4] = {0, 0, 1, 0};
unsigned char Step,Low,High;
bit Rotate;

bit now_a, now_b, pre_a, pre_b;

static unsigned char New, EncPlus, EncMinus;//Переменные нового значения энкодера, промежуточные переменные + и -

//
// массивы
//
unsigned char data	OutputBuffer[6];
unsigned char data	In_Packet[10];

//unsigned char waveform[256];
//
// Переменные для функций работы с EEPROM

unsigned char* pSMB_DATA_IN;           // Global pointer for SMBus data
                                       // All receive data is written here

unsigned char SMB_SINGLEBYTE_OUT;      // Global holder for single byte writes.

unsigned char* pSMB_DATA_OUT;          // Global pointer for SMBus data.
                                       // All transmit data is read from here

unsigned char SMB_DATA_LEN;            // Global holder for number of bytes
                                       // to send or receive in the current
                                       // SMBus transfer.

unsigned char WORD_ADDR_HIGH;               // Global holder for the EEPROM word
                                       // address that will be accessed in
                                       // the next transfer

unsigned char WORD_ADDR_LOW;

bit SMB_BUSY = 0;                      // Software flag to indicate when the
                                       // EEPROM_ByteRead() or
                                       // EEPROM_ByteWrite()
                                       // functions have claimed the SMBus

bit SMB_RW;                            // Software flag to indicate the
                                       // direction of the current transfer

bit SMB_SENDWORDADDR_LOW;                  // When set, this flag causes the ISR
                                       // to send the 8-bit <WORD_ADDR>
                                       // after sending the slave address.
bit SMB_SENDWORDADDR_HIGH;

bit SMB_RANDOMREAD;                    // When set, this flag causes the ISR
                                       // to send a START signal after sending
                                       // the word address.
                                       // For the 24LC02B EEPROM, a random read
                                       // (a read from a particular address in
                                       // memory) starts as a write then
                                       // changes to a read after the repeated
                                       // start is sent. The ISR handles this
                                       // switchover if the <SMB_RANDOMREAD>
                                       // bit is set.

bit SMB_ACKPOLL;                       // When set, this flag causes the ISR
                                       // to send a repeated START until the
                                       // slave has acknowledged its address

/*** [BEGIN] USB Descriptor Information [BEGIN] ***/

SEGMENT_VARIABLE(USB_VID, U16, SEG_CODE) = 0x10c4;
SEGMENT_VARIABLE(USB_PID, U16, SEG_CODE) = 0xea61;
SEGMENT_VARIABLE(USB_MfrStr[], char , SEG_CODE) = // Manufacturer String
{
   0x1A,
   0x03,
   'H',0,
   'a',0,
   't',0,
   'a',0,
   'b',0,
   '@',0,
   'C',0,
   'o',0,
   ' ',0

};
SEGMENT_VARIABLE(USB_ProductStr[], unsigned char , SEG_CODE) = // Product Desc. String
{
   0x10,
   0x03,
   'H',0,
   'a',0,
   't',0,
   'S',0,
   'a',0,
   'm',0,
   'w',0,
   'i',0,
   'l',0,
   'l',0
};

SEGMENT_VARIABLE(USB_SerialStr[], unsigned char , SEG_CODE) = // Serial Number String
{
   0x0A,
   0x03,
   '0',0,
   '0',0,
   '0',0,
   '1',0,
};

SEGMENT_VARIABLE(USB_MaxPower, unsigned char , SEG_CODE) = 15;    // Max current = 30 mA
                                                      // (15 * 2)
SEGMENT_VARIABLE(USB_PwAttributes, unsigned char , SEG_CODE) = 0x80;    // Bus-powered,
                                                          // remote wakeup not
                                                         // supported
SEGMENT_VARIABLE(USB_bcdDevice, U16, SEG_CODE) = 0x0100;    // Device release
                                                            // number 1.00

SEGMENT_VARIABLE(DEVICE_NAME_Str[], unsigned char , SEG_CODE) = // Serial Number String
{'H','a','t','S','a','m' };
SEGMENT_VARIABLE(DEVICE_SN_Str[], unsigned char , SEG_CODE) = { 1,2,3,4 };
SEGMENT_VARIABLE(LCD_STRING[], unsigned char, SEG_CODE) = {'-','-','-','-','-','-'};
/*** [ END ] USB Descriptor Information [ END ] ***/

#define ERROR_EEPROM 1

void main(void)
{
	unsigned char i;
	bit UpDown = 0;
	int	temp;
	PCA0MD &= ~0x40;                       // Disable Watchdog timer
	Initialize();

//	USB_Clock_Start();                     // Init USB clock *before* calling USB_Init
//	USB_Init(USB_VID,USB_PID,USB_MfrStr,USB_ProductStr,USB_SerialStr,USB_MaxPower,USB_PwAttributes,USB_bcdDevice);
	
//	USB_Int_Enable();

// If slave is holding SDA low because of an improper SMBus reset or error
 	
//	while (1)

	LedsSwitchOff();
	
	SEGMENT_A = 1;
	LED1 = 0;

	while(!EEPROM_SDA)
   	{

  // Provide clock pulses to allow the slave to advance out
      // of its current state. This will allow it to release SDA.
		XBR1 = 0x40;                     // Enable Crossbar
    	EEPROM_SCL = 0;                  // Drive the clock low
    	for (i = 0; i < 255; i++) {  } // Hold the clock low
    	EEPROM_SCL = 1; ;//                 // Release the clock
    	while(!EEPROM_SCL);// { }//;              // Wait for open-drain
                                       	 // clock output to rise
    	for(i = 0; i < 10; i++);         // Hold the clock high

		XBR1 = 0x00;                     // Disable Crossbar
   	}
	SEGMENT_A = 0;
	LED1 = 1;
	
	EIE1 |= 0x01;                       // Enable the SMBus interrupt
	EA = 1;
	ET0 = 1; // Timer0
	
	LcdOutputLine(5);
	ResetCounterToOutputBuffer();

// Увиличение счетчика сброса <HARD_RESET>
	if (OutputBuffer[0] < 0xFF) OutputBuffer[0]++;
	else 
	{ 
		OutputBuffer[0] = 0; 
		if (OutputBuffer[1] < 0xFF) OutputBuffer[1]++;
		else
		{
			OutputBuffer[1] = 0;
			if (OutputBuffer[2] < 0xFF) OutputBuffer[2]++;
			else
			{
				OutputBuffer[2] = 0;
				if (OutputBuffer[3] < 0xFF) OutputBuffer[3]++;
			}
		}
	}
	OutputBufferToResetCounter();

//	SoftReset(SOFT_RESET);

	Counter = 0;
	Counter = EEPROM_ByteRead(EEPROM_COUNTER_ADDR_HIGH);
	Counter = Counter<<8;
	Counter |= EEPROM_ByteRead(EEPROM_COUNTER_ADDR_LOW);
	
	Discret = 0;
	Discret = EEPROM_ByteRead(EEPROM_DISCRET_ADDR_HIGH);
	Discret = Discret <<8;
	Discret |= EEPROM_ByteRead(EEPROM_DISCRET_ADDR_LOW);

	LcdMode = EEPROM_ByteRead(EEPROM_LCDMODE_ADDR);

	if (LcdMode >1) { LcdMode = 1; LcdOutputLine(1); EEPROM_ByteWrite(EEPROM_LCDMODE_ADDR,LcdMode); }
	while (1) 
	{
//	if (Counter > 39000) Counter = 39000;
//	EncoderScan5();
	FlagPoint = 0;

	switch (LcdMode)
	{
	case 0:
		{
			TempCounter = Counter & 0xFFFF;
			if (TempCounter > 9999) 
			{
				temp = TempCounter / 10000;
				OutputBuffer[0] = temp;
				TempCounter = TempCounter - temp*10000;
			}
			else OutputBuffer[0] = 0;

			if (TempCounter > 999) 
			{
				temp = TempCounter / 1000;
				OutputBuffer[1] = temp;
				TempCounter = TempCounter - temp*1000;
			} else OutputBuffer[1] = 0;

			if (TempCounter > 99) 
			{
				temp = TempCounter / 100;
				OutputBuffer[2] = temp;
				TempCounter = TempCounter - temp*100;
			} else OutputBuffer[2] = 0;

			if (TempCounter > 9) 
			{
				temp = TempCounter / 10;
				OutputBuffer[3] = temp;
				TempCounter = TempCounter - temp*10;
			} else OutputBuffer[3] = 0;
			OutputBuffer[4] = TempCounter ;
		} break;
	case 1:
		{
			TempCounter = ((Counter*100) / Discret);
			OutputBuffer[0] = 0;
			if (TempCounter > 9999) 
			{
				temp = TempCounter / 10000;
				OutputBuffer[1] = temp;
				TempCounter = TempCounter - temp*10000;
			}
			else OutputBuffer[1] = 0;

			if (TempCounter > 999) 
			{
				temp = TempCounter / 1000;
				OutputBuffer[2] = temp;
				TempCounter = TempCounter - temp*1000;
			} else OutputBuffer[2] = 0;

			if (TempCounter > 99) 
			{
				temp = TempCounter / 100;
				OutputBuffer[3] = temp;
				TempCounter = TempCounter - temp*100;
			} else OutputBuffer[3] = 0;
			if (TempCounter > 9) 
			{
				temp = TempCounter / 10;
				OutputBuffer[4] = temp;
				TempCounter = TempCounter - temp*10;
			} else OutputBuffer[4] = 0;
			OutputBuffer[5] = TempCounter ;
		} break;
	}


	if ((KEY1 == 0) & (LongKeyFlag == 0)) 
	{
		LongKeyFlagCounter++;
		if (LongKeyFlagCounter > 1000) 
		{ 
			LongKeyFlag = 1;
			LongKeyFlagCounter = 0;
		} 
	}

	if (KEY2 == 0) 
	{
		if ((KeyFlag1 == 0) | (LongKeyFlag == 1))
		{
			Counter ++;
			KeyFlag1 = 1; 
		}
	} else { KeyFlag1 = 0; LongKeyFlag = 0; }

	if (KEY1 == 0) Counter = 0;

	if (KEY3 == 0)  // Смена режима вывода на дисплюй (ММ или Счётчик сигналов)
	{
		if (KeyFlag3 == 0)
		{
			if (LcdMode == 0) LcdMode = 1; else LcdMode = 0;
			LcdOutputLine(2);
			EEPROM_ByteWrite(EEPROM_LCDMODE_ADDR,LcdMode);
			KeyFlag3 = 1;
		}
	} else KeyFlag3 = 0;

	if (KEY4 == 0) // запись в память EEPROM дискретизации (Счётчик/1 ММ)
	{
		if (KeyFlag4 == 0)
		{
			Discret = Counter;
			LcdOutputLine(4);
			WriteDiscretToEEprom();
			WriteCounterToEEprom();
			KeyFlag4 = 1;
		} else KeyFlag4 = 0;
	}

	}
}

void EncoderScan2(void)
{
	EncState = P0 >> 2;
	EncState = ((OldState<<2) | EncState) & 0x0F;

	switch (EncState)
	{
		case 1: Counter--; break;// Case &00000001 
		case 2: Counter++;break;
		case 7: Counter--;break;
		case 4: Counter++;break;
		case 0x0D:	Counter++;break;
		case 0x0E:	Counter--;break;
		case 0x0B:	Counter++;break;
		case 8:		Counter--; 
	}
	OldState = EncState;
}

void EncoderScan1(void)
{
	unsigned char New;
 
	New = (P0 & 0x0C) >> 2; // PINB & 0x03;	// Берем текущее значение 
			// И сравниваем со старым
 
// Смотря в какую сторону оно поменялось -- увеличиваем
// Или уменьшаем счетный регистр
 
	switch(EncState)
	{
	case 2:
		{
		if(New == 3) Counter++;
		if(New == 0) Counter--; 
		break;
		}
 
	case 0:
		{
		if(New == 2) Counter++;
		if(New == 1) Counter--; 
		break;
		}
	case 1:
		{
		if(New == 0) Counter++;
		if(New == 3) Counter--; 
		break;
		}
	case 3:
		{
		if(New == 1) Counter++;
		if(New == 2) Counter--; 
		break;
		}
	}
 
	EncState = New;		// Записываем новое значение 
				// Предыдущего состояния
}

void EncoderScan3 (void)
{
  EncTemp = EncIN;
  Del(10); // ??????????????? ????????
  EncTemp |= EncIN;
#if(EncA < EncB) //????? ???????? ????
  EncTemp >>= EncA;
#else
  EncTemp >>= EncB;
#endif
  EncTemp &= 0x03; 
  if (EncN < 4)
  {
    if (((EncOld[0] == 0x03)&&(EncTemp != EncOld[EncN - 1]))||
        ((EncOld[0] == 0x00)&&(EncTemp == 0x03))) // проверка последовательности команд от энкодера
    {
      EncOld[EncN] = EncTemp;
      EncN ++;
    }
  }
  else
  {
      if ((EncOld[1] == 0x01)&&
          (EncOld[2] == 0x00)&&
          (EncOld[3] == 0x02)) // проверка совпадения принятых данных с прямой посл-ю
      {
        Counter++;
      }
      else
        if ((EncOld[1] == 0x02)&&
            (EncOld[2] == 0x00)&&
            (EncOld[3] == 0x01)) // проверка совпадения принятых данных с обратной посл-ю
        {
          Counter--;
        }
    EncN = 0; // ????????? ??????
    EncOld[0] = 0x00;
    EncOld[1] = 0x00;
    EncOld[2] = 0x01;
    EncOld[3] = 0x00;
  }
}

void EncoderScan4(void)
{
 // запомнить текущее состояние сигналов энкодера.
	now_a = EXT_INT0; // сигнал на выходе "А" энкодера PB3
	now_b = EXT_INT1; // сигнал на выходе "B" энкодера PB4  
 
	if ((pre_b != now_b)||(pre_a != now_a))  // Если изменился сигнал А или В то  /*  "+" тик (отсчет условно "по часовой") если выполняются 4 условия
	{ 

		if (!now_b) // 1) В = 0
		{
 			if (now_a) // 2) A = 1
			{
				if (now_a != pre_a) // 3) A изменился
				{
					if (now_b == pre_b) // 4) B не изменился 
					{
     					Counter-- ;               // посчитать тик "по часовой"
					}
				}
			}
		}     // вращение происходит по-часовой

 /*  "-" тик (отсчет условно "против часовой") если выполняются 4 условия:   */      
		if (now_b) // 1) В = 1
		{
			if (!now_a) // 2) A = 0
			{
				if (now_a == pre_a) // 3) A не изменился
				{
					if (now_b != pre_b)// 4) B изменился 
					{
     					Counter++ ;               // посчитать тик "против часовой"
					}
				}
			}
		} // вращение происходит против-часовой
	}
	pre_a = now_a; // обновить "прошлые" сигналы энкодера 
	pre_b = now_b; // для - interrupt [PCINT0] void pin_change_isr(void)
}

void EncoderScan5(void)//Функция обработки энкодера
{
 
    New = (P0 & 0x0C) >> 2; // PINB & 0x03;	// Берем текущее значение 
 
    if(New != EncState)//Если значение изменилось по отношению к прошлому
    {
        switch(EncState) //Перебор прошлого значения энкодера
	    {
	    case 2:if(New == 3) EncPlus++;//В зависимости от значения увеличиваем
		             if(New == 0) EncMinus++;//Или уменьшаем  
		       break;
	    case 0:if(New == 2) EncPlus++;
		             if(New == 1) EncMinus++; 
		       break;
	    case 1:if(New == 0) EncPlus++;
		             if(New == 3) EncMinus++; 
		       break;
	    case 3:if(New == 1) EncPlus++;
		             if(New == 2) EncMinus++; 
		       break;
        default:break;
	    }
		
		if(EncPlus == 4) //если прошёл один "щелчок"
		{
			Counter++;
			EncPlus = 0;
		}
		
		if(EncMinus == 4) //если прошёл один "щелчок"
		{
		    Counter--;
			EncMinus = 0;
		}
        EncState = New;	// Записываем новое значение предыдущего состояния
	}
}

void LcdOutputLine(unsigned char delay)
{
	unsigned char i,y;
	TCON &= ~0x10;
	ET0 = 0;
	
	LedsSwitchOff();
	SEGMENT_G = 1;
	
	for (i=0;i<6;i++)
	{
		for (y=0;y<delay;y++) //{ Del_500mks(); Del_500mks(); Del_500mks(); Del_500mks(); }
		switch (i)
		{
			case 0: LED1 = 0; break;
			case 1: LED2 = 0; break;
			case 2: LED3 = 0; break;
			case 3: LED4 = 0; break;
			case 4: LED5 = 0; break;
			case 5: LED6 = 0; break;
		}	
	}
	ET0 = 1;
	TCON |= 0x10;
}

void WriteCounterToEEprom(void)
{
	unsigned char temp_byte;
	temp_byte = Counter;
	EEPROM_ByteWrite(EEPROM_COUNTER_ADDR_LOW, temp_byte);
	temp_byte = Counter>>8;
	EEPROM_ByteWrite(EEPROM_COUNTER_ADDR_HIGH,temp_byte);

	LedsSwitchOff();
	LcdOutputLine(2);
}

void WriteDiscretToEEprom(void)
{
	unsigned char temp_byte;
	
	if (Discret == 0) Discret = DEFAULT_DISCRET;
	temp_byte = Discret;
	EEPROM_ByteWrite(EEPROM_DISCRET_ADDR_LOW, temp_byte);
	temp_byte = Discret>>8;
	EEPROM_ByteWrite(EEPROM_DISCRET_ADDR_HIGH,temp_byte);

	LedsSwitchOff();
	LcdOutputLine(2);
}

void ResetCounterToOutputBuffer(void)
{
	OutputBuffer[0] = EEPROM_ByteRead(EEPROM_RESET_COUNTER_ADDR);
	OutputBuffer[1] = EEPROM_ByteRead(EEPROM_RESET_COUNTER_ADDR+1);
	OutputBuffer[2] = EEPROM_ByteRead(EEPROM_RESET_COUNTER_ADDR+2);
	OutputBuffer[3] = EEPROM_ByteRead(EEPROM_RESET_COUNTER_ADDR+3);
}

void OutputBufferToResetCounter(void)
{
		EEPROM_ByteWrite(EEPROM_RESET_COUNTER_ADDR, OutputBuffer[0]);
		EEPROM_ByteWrite(EEPROM_RESET_COUNTER_ADDR+1, OutputBuffer[1]);
		EEPROM_ByteWrite(EEPROM_RESET_COUNTER_ADDR+2, OutputBuffer[2]);
		EEPROM_ByteWrite(EEPROM_RESET_COUNTER_ADDR+3, OutputBuffer[3]);
}

void OutSymbol(unsigned char LedNumber, unsigned char SymbolCode)
{
	LedsSwitchOff();

	switch (SymbolCode)
	{
		case 0x2D:
		{
			SEGMENT_G = 1;
		} break;
		case 0x30:
		{
			SEGMENT_A = 1;
			SEGMENT_B = 1;
			SEGMENT_C = 1;
			SEGMENT_D = 1;
			SEGMENT_E = 1;
			SEGMENT_F = 1;
		} break;
		case 0x31:
		{
			SEGMENT_B = 1;
			SEGMENT_C = 1;
		} break;
		case 0x32:
		{
			SEGMENT_A = 1;
			SEGMENT_B = 1;
			SEGMENT_G = 1;
			SEGMENT_E = 1;
			SEGMENT_D = 1;
		} break;
		case 0x33:
		{
			SEGMENT_A = 1;
			SEGMENT_B = 1;
			SEGMENT_C = 1;
			SEGMENT_D = 1;
			SEGMENT_G = 1;
		} break;
		case 0x34:
		{
			SEGMENT_B = 1;
			SEGMENT_C = 1;
			SEGMENT_F = 1;
			SEGMENT_G = 1;
		} break;
		case 0x35:
		{
			SEGMENT_A = 1;
			SEGMENT_F = 1;
			SEGMENT_G = 1;
			SEGMENT_C = 1;
			SEGMENT_D = 1;
		} break;
		case 0x36:
		{
			SEGMENT_A = 1;
			SEGMENT_F = 1;
			SEGMENT_G = 1;
			SEGMENT_E = 1;
			SEGMENT_D = 1;
			SEGMENT_C = 1;
		} break;
		case 0x37:
		{
			SEGMENT_A = 1;
			SEGMENT_B = 1;
			SEGMENT_C = 1;
		} break;
		case 0x38:
		{
			SEGMENT_A = 1;
			SEGMENT_B = 1;
			SEGMENT_C = 1;
			SEGMENT_D = 1;
			SEGMENT_E = 1;
			SEGMENT_F = 1;
			SEGMENT_G = 1;
		} break;
		case 0x39:
		{
			SEGMENT_A = 1;
			SEGMENT_B = 1;
			SEGMENT_C = 1;
			SEGMENT_D = 1;
			SEGMENT_F = 1;
			SEGMENT_G = 1;
		} break;
	}

	if (FlagPoint == 1) SEGMENT_POINT = 1;
	switch (LedNumber)
	{
		case 1: LED1 = 0; break;
		case 2: LED2 = 0; break;
		case 3: LED3 = 0; break;
		case 4: LED4 = 0; break;
		case 5: LED5 = 0; break;
		case 6: LED6 = 0; break;
	}	
}

void LedsSwitchOff(void)
{
	LED1 = 1;
	LED2 = 1;
	LED3 = 1;
	LED4 = 1;
	LED5 = 1;
	LED6 = 1;

	SEGMENT_A = 0;
	SEGMENT_B = 0;
	SEGMENT_C = 0;
	SEGMENT_D = 0;
	SEGMENT_E = 0;
	SEGMENT_F = 0;
	SEGMENT_G = 0;
	SEGMENT_POINT = 0;
}

//-------------------------
// Initialize
//-------------------------
// Called when a DEV_CONFIGURED interrupt is received.
// - Enables all peripherals needed for the application
//
void Initialize(void)
{
	Port_Init();                           // Initialize crossbar and GPIO
	OSCILLATOR_Init ();
//	OSCICN |= 0x83;							// задаём частоту
	Timer0_Init();                          // Initialize timer2
	Timer1_Init(); // smbus SCL
	Timer3_Init(); // smbus
	SMBus_Init ();
	Ext_Interrupt_Init();
}

void OSCILLATOR_Init (void)
{
#ifdef EXTERNAL_CRYSTAL
	int i;
    OSCXCN    = 0x67;
    for (i = 0; i < 256; i++);  // Wait 1ms for initialization
    while (!(OSCXCN & 0x80));           // Wait for crystal osc. to settle
   	RSTSRC = 0x06;                      	// Enable missing clock detector and
    	                                   	// VDD Monitor reset

//   	CLKMUL = 0x00;
	CLKSEL = 0x01;                      	// Select external oscillator as system
                                       		// clock source
//	CLKMUL |= 0x80;
//    for (i = 0; i < 256; i++);  // Wait 1ms for initialization
//    CLKMUL |= 0xC0;
//	while (!(CLKMUL & 0x20));           // 
	
   	OSCICN = 0x03;                      	// Disable the internal oscillator.
#else
	OSCICN = 0x83;							// задаём частоту
	RSTSRC |= 0x04;                      	// Enable missing clock detector and
#endif
}

//-------------------------
// Timer_Init
//-------------------------
// Timer initialization
// - 1 mhz timer 2 reload, used to check if switch pressed on overflow and
// used for ADC continuous conversion
//
void Timer0_Init(void)
{
	TL0 = 0;
	TH0 = 1;

	TMOD = 0x02; 	//	00 - 13bit, 01 - 16bit, 02 - 8 bit;;
					//	T0M1=0; // 16-РАЗРЯДНЫЙ ТАЙМЕР

#ifdef EXTERNAL_CRYSTAL
	CKCON = 0x03; 
#else
	CKCON = 0x00; // делитель на 12 (01 - на 4, 10 - на 48, на 8  - EXT CLK)
#endif
	TCON = 0x10;                        // Timer0 ON
}

void Timer1_Init (void)
{
#if ((SYSCLK/SMB_FREQUENCY/3) < 255)
   #define SCALE 1
      CKCON |= 0x08;                   // Timer1 clock source = SYSCLK
#elif ((SYSCLK/SMB_FREQUENCY/4/3) < 255)
   #define SCALE 4
      CKCON |= 0x01;
      CKCON &= ~0x0A;                  // Timer1 clock source = SYSCLK / 4
#endif

   TMOD |= 0x20;                        // Timer1 in 8-bit auto-reload mode

   TH1 = -(SYSCLK/SMB_FREQUENCY/12/3); // Timer1 configured to overflow at 1/3
                                       // the rate defined by SMB_FREQUENCY

   TL1 = TH1;                          // Init Timer1

   TR1 = 1;                            // Timer1 enabled
}


void Timer3_Init (void)
{
   TMR3CN = 0x00;                      // Timer3 configured for 16-bit auto-
                                       // reload, low-byte interrupt disabled

   CKCON &= ~0x40;                     // Timer3 uses SYSCLK/12
   TMR3RL = -(SYSCLK/12/40);           // Timer3 configured to overflow after
   TMR3 = TMR3RL;                      // ~25ms (for SMBus low timeout detect)

   EIE1 |= 0x80;                       // Timer3 interrupt enable
   TMR3CN |= 0x04;                     // Start Timer3
}

void Port_Init(void)
{
#ifdef EXTERNAL_CRYSTAL
   	P0MDIN &= ~0x0C;                    // P0.2, P0.3 are analog 
#endif

#ifdef EXTERNAL_CRYSTAL
	P0SKIP	|= 0x0C;
#endif

	P0MDOUT = 0xFF; // все на выход
	P0MDOUT &= ~0x7F; // bit6,5,4,3 - клавиатура, bit2 вход /INT0, /INT1, bit0,1 - I2C EEprom

	P1MDOUT = 0xFF;  // все на выход

	P2MDOUT = 0xFF;  // все на выход
	P2MDOUT &= ~0x20; // Int0 дополнение - вход

//	P2MDOUT &= ~0xE0; // bit 5,6,7 input

	P0 |= 0x78; // p0.7, p0.6, p0.5 - клавиатура
	P0 |= 0x0C; // p0.2  - вход /INT0
	P0 &= ~0x03; // p0.0 , p0.1 - TX / RX I2C

	P2 |= 0xE0; 

	XBR0    = 0x04;						// SMBUS enabled
	XBR1    = 0x40;                     // Enable Crossbar and weak pull-ups
}

//
// SMBUS INIT
//
//
void SMBus_Init (void)
{
	SMB0CF = 0x5D;                      // Use Timer1 overflows as SMBus clock
                                       // source;
                                       // Disable slave mode;
                                       // Enable setup & hold time extensions;
                                       // Enable SMBus Free timeout detect;
                                       // Enable SCL low timeout detect;

	SMB0CF |= 0x80;                     // Enable SMBus;
}

void Ext_Interrupt_Init (void)
{
	IP = 0x05;// int1, int0 высокий приоритет

//	if (KEY1 == 0) TCON &= ~0x01;                        // /INT 0 если активен (bit = 1 если фронтом)
//	else TCON |= 0x01; // фронтом
	TCON |= 0x05; // фронтом
	IT01CF &= ~0x0A;	// полярность /INT0 ( 0 - низкий активный уровень)1
// выбор активности или HIGH или LOW
//	if (KEY2 == 1) IT01CF &= ~0x08;	// полярность /INT0 ( 0 - низкий активный уровень)1
//	else IT01CF |= 0x08; // 1 - высокий

//	if (KEY3 == 0) TCON &= ~0x04;                        // /INT 1 если активен (bit = 1 если фронтом)
//	else TCON |= 0x04; // фронтом

// выбор активности или HIGH или LOW
//	if (KEY4 == 0) IT01CF &= ~0x80;	// полярность /INT1 ( 0 - низкий активный уровень)
//	else IT01CF |= 0x80; // 1 - высокий

	IT01CF |= 0x02;	// 
	IT01CF &= ~0x05; // выбор порта P0.2 для /INT0

	IT01CF |= 0x30;	// 
	IT01CF &= ~0x40; // выбор порта P0.3 для /INT1

	EX0 = 1;                            // Enable /INT0 interrupts
	EX1 = 1;                            // Enable /INT1 interrupts
}


//-----------------------------------------------------------------------------
// EEPROM_ByteWrite ()
//-----------------------------------------------------------------------------
//
// Return Value : None
// Parameters   :
//   1) unsigned char addr - address to write in the EEPROM
//                        range is full range of character: 0 to 255
//
//   2) unsigned char dat - data to write to the address <addr> in the EEPROM
//                        range is full range of character: 0 to 255
//
// This function writes the value in <dat> to location <addr> in the EEPROM
// then polls the EEPROM until the write is complete.
//
void EEPROM_ByteWrite(U16 addr, unsigned char dat)
{
   while (SMB_BUSY);                   // Wait for SMBus to be free.
   SMB_BUSY = 1;                       // Claim SMBus (set to busy)

	WORD_ADDR_HIGH = addr >> 8;                   // Set the target address in the
	WORD_ADDR_LOW = addr & 0xFF;

   // Set SMBus ISR parameters
#ifdef EEPROM_24C128
	SMB_SENDWORDADDR_HIGH = 1;
#endif
#ifdef EEPROM_24C16
	SMB_SENDWORDADDR_HIGH = 0;
#endif
	SMB_RW = WRITE;                     // Mark next transfer as a write
	SMB_SENDWORDADDR_LOW = 1;               // Send Word Address after Slave Address

	SMB_RANDOMREAD = 0;                 // Do not send a START signal after
                                       // the word address
	SMB_ACKPOLL = 1;                    // Enable Acknowledge Polling (The ISR
                                       // will automatically restart the
                                       // transfer if the slave does not
                                       // acknoledge its address.

   // Specify the Outgoing Data
	SMB_SINGLEBYTE_OUT = dat;           // Store <dat> (local variable) in a
                                       // global variable so the ISR can read
                                       // it after this function exits

   // The outgoing data pointer points to the <dat> variable
	pSMB_DATA_OUT = &SMB_SINGLEBYTE_OUT;

//	SMB_DATA_LEN = 1;                   // Specify to ISR that the next transfer
                                       // will contain one data byte

   // Initiate SMBus Transfer
	STA = 1;
}


//-----------------------------------------------------------------------------
// EEPROM_ByteRead ()
//-----------------------------------------------------------------------------
//
// Return Value :
//   1) unsigned char data - data read from address <addr> in the EEPROM
//                        range is full range of character: 0 to 255
//
// Parameters   :
//   1) unsigned char addr - address to read data from the EEPROM
//                        range is full range of character: 0 to 255
//
// This function returns a single byte from location <addr> in the EEPROM then
// polls the <SMB_BUSY> flag until the read is complete.
//
unsigned char EEPROM_ByteRead(U16 addr)
{
   unsigned char retval;               // Holds the return value

   
   while (SMB_BUSY);                   // Wait for SMBus to be free.
   SMB_BUSY = 1;                       // Claim SMBus (set to busy)


	WORD_ADDR_HIGH = addr >> 8;                   // Set the target address in the
	WORD_ADDR_LOW = addr & 0xFF; 

   // Set SMBus ISR parameters
#ifdef EEPROM_24C128
	SMB_SENDWORDADDR_HIGH = 1;
#endif
#ifdef EEPROM_24C16
	SMB_SENDWORDADDR_HIGH = 0;
#endif

   SMB_SENDWORDADDR_LOW = 1;               // Send Word Address after Slave Address
   SMB_RW = WRITE;                     // A random read starts as a write
                                       // then changes to a read after
                                       // the repeated start is sent. The
                                       // ISR handles this switchover if
                                       // the <SMB_RANDOMREAD> bit is set.
   SMB_RANDOMREAD = 1;                 // Send a START after the word address
   SMB_ACKPOLL = 1;                    // Enable Acknowledge Polling


   // Specify the Incoming Data
   pSMB_DATA_IN = &retval;             // The incoming data pointer points to
                                       // the <retval> variable.

//   SMB_DATA_LEN = 1;                   // Specify to ISR that the next transfer
                                       // will contain one data byte

   // Initiate SMBus Transfer
   STA = 1;
   while(SMB_BUSY);                    // Wait until data is read

   return retval;

}

void Suspend_Device(void)
{
   // Disable peripherals before calling USB_Suspend()
//	P0MDIN = 0x0;                       // Port 0 configured as analog input
//	P1MDIN = 0x00;                       // Port 1 configured as analog input
//	P2MDIN = 0x0;
//	ADC0CN &= ~0x80;                     // Disable ADC0
//	ET0 = 0;
//	ET2 = 0;                             // Disable Timer 2 Interrupts

	USB_Suspend();                       // Put the device in suspend state
										// Once execution returns from USB_Suspend(), device leaves suspend state.
										// Reenable peripherals
//	ADC0CN |= 0x80;                      // Enable ADC0
//	P0MDIN = 0xFF;
//	P1MDIN = 0xFF;                       // Port 1 pin 7 set as analog input
//	P2MDIN = 0xFF;
//	ET0 = 1;
//	ET2 = 1;							// Enable Timer 2 Interrupts
}

//
//  IIII  SS  RRR                                   
//   II  S  S R  R                                  
//   II  SS   R  R                                  
//   II   SS  RRR                                   
//   II    SS R  R                                  
//   II  S  S R  R                                  
//  IIII  SS  R  R                                  
//
//
//
//-----------------------------------------------------------------------------
// /INT0 ISR
//-----------------------------------------------------------------------------
//
// Whenever a negative edge appears on P0.0, LED1 is toggled.
// The interrupt pending flag is automatically cleared by vectoring to the ISR
//
//-----------------------------------------------------------------------------
void INT0_ISR (void) interrupt 0
{
	Counter++;
}
void INT1_ISR (void) interrupt 2
{
	Counter--;
}

//-----------------------------------------------------------------------------
// SMBus Interrupt Service Routine (ISR)
//-----------------------------------------------------------------------------
//
void SMBus_ISR (void) interrupt 7
{
   bit FAIL = 0;                       // Used by the ISR to flag failed
                                       // transfers

   static char i;                      // Used by the ISR to count the
                                       // number of data bytes sent or
                                       // received

   static bit SEND_START = 0;          // Send a start

   switch (SMB0CN & 0xF0)              // Status vector
   {
      // Master Transmitter/Receiver: START condition transmitted.
      case SMB_MTSTA:
         SMB0DAT = TARGET;             // Load address of the target slave
         SMB0DAT &= 0xFE;              // Clear the LSB of the address for the
                                       // R/W bit
         SMB0DAT |= SMB_RW;            // Load R/W bit

#ifdef EEPROM_24C16
		SMB0DAT = SMB0DAT | ((WORD_ADDR_HIGH & 0x07)<<1);
#endif

         STA = 0;                      // Manually clear START bit
         i = 0;                        // Reset data byte counter
         break;

      // Master Transmitter: Data byte (or Slave Address) transmitted
      case SMB_MTDB:
         if (ACK)                      // Slave Address or Data Byte
         {                             // Acknowledged?
            if (SEND_START)
            {
               STA = 1;
               SEND_START = 0;
               break;
            }

            if(SMB_SENDWORDADDR_HIGH)       // Are we sending the word address?
            {
               SMB_SENDWORDADDR_HIGH = 0;   // Clear flag
               SMB0DAT = WORD_ADDR_HIGH;    // Send word address
               break;
            }

            if(SMB_SENDWORDADDR_LOW)       // Are we sending the word address?
            {
               SMB_SENDWORDADDR_LOW = 0;   // Clear flag
               SMB0DAT = WORD_ADDR_LOW;    // Send word address

               if (SMB_RANDOMREAD)
               {
                  SEND_START = 1;      // Send a START after the next ACK cycle
                  SMB_RW = READ;
               }

               break;
            }

            if (SMB_RW==WRITE)         // Is this transfer a WRITE?
            {

               if (i < 1)   // Is there data to send?
               {
//                  // send data byte
                  SMB0DAT = *pSMB_DATA_OUT;
//
                  // increment data out pointer
                  pSMB_DATA_OUT++;

                  // increment number of bytes sent
                  i++;
               }
               else
               {
                 STO = 1;              // Set STO to terminte transfer
                 SMB_BUSY = 0;         // Clear software busy flag
               }
            }
            else {}                    // If this transfer is a READ,
                                       // then take no action. Slave
                                       // address was transmitted. A
                                       // separate 'case' is defined
                                       // for data byte recieved.
         }
         else                          // If slave NACK,
         {
            if(SMB_ACKPOLL)
            {
               STA = 1;                // Restart transfer
            }
            else
            {
               FAIL = 1;               // Indicate failed transfer
            }                          // and handle at end of ISR
         }
         break;

      // Master Receiver: byte received
      case SMB_MRDB:
         if ( i < 1 )       // Is there any data remaining?
         {
            *pSMB_DATA_IN = SMB0DAT;   // Store received byte
            pSMB_DATA_IN++;            // Increment data in pointer
            i++;                       // Increment number of bytes received
            ACK = 1;                   // Set ACK bit (may be cleared later
                                       // in the code)

         }

         if (i == 1)        // This is the last byte
         {
            SMB_BUSY = 0;              // Free SMBus interface
            ACK = 0;                   // Send NACK to indicate last byte
                                       // of this transfer
            STO = 1;                   // Send STOP to terminate transfer
         }

         break;

      default:
         FAIL = 1;                     // Indicate failed transfer
                                       // and handle at end of ISR
         break;
   }

   if (FAIL)                           // If the transfer failed,
   {
      SMB0CF &= ~0x80;                 // Reset communication
      SMB0CF |= 0x80;
      STA = 0;
      STO = 0;
      ACK = 0;

      SMB_BUSY = 0;                    // Free SMBus

      FAIL = 0;
   }

   SI = 0;                             // Clear interrupt flag

}

//-------------------------
// Timer0_ISR
//-------------------------
// Called when timer 2 overflows, check to see if switch is pressed,
// then watch for release.
//
INTERRUPT(Timer0_ISR, INTERRUPT_TIMER0)
{
	unsigned char i;
	static int low_counter=0;  // Define counter variable

	TL0 = TIMER0_RELOAD_LOW;            // Reinit Timer0 Low register

//	if ((low_counter2++) == Timer0_RateEncoder )
//	{
//		EncoderScan5();
//		low_counter2 = 0;
//	}
	if ((low_counter++) == Timer0_Rate)
	{
//		if (LcdMode = 0) j = 5; else j = 6;
		for (i=0;i<(5 + LcdMode);i++) 
		{
			if (i == 4) FlagPoint = 1; else FlagPoint = 0;
			if (LcdMode == 0) FlagPoint = 1;
			OutSymbol(i+1,0x30 | OutputBuffer[i]);
			Del	(200);
		}
		low_counter = 0;
	}
}
//-------------------------
// Timer2_ISR
//-------------------------
// Called when timer 2 overflows, check to see if switch is pressed,
// then watch for release.
//
INTERRUPT(Timer2_ISR, INTERRUPT_TIMER2)
{
	TF2H = 0;                              // Clear Timer2 interrupt flag
	ET2=1;
}

//-----------------------------------------------------------------------------
// Timer3 Interrupt Service Routine (ISR)
//-----------------------------------------------------------------------------
//
// A Timer3 interrupt indicates an SMBus SCL low timeout.
// The SMBus is disabled and re-enabled if a timeout occurs.
//
void Timer3_ISR (void) interrupt 14
{
   SMB0CF &= ~0x80;                    // Disable SMBus
   SMB0CF |= 0x80;                     // Re-enable SMBus
   TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending flag
   SMB_BUSY = 0;                       // Free bus
}

INTERRUPT(USB_API_TEST_ISR, INTERRUPT_USBXpress)
{
	unsigned char INTVAL = Get_Interrupt_Source();

   if (INTVAL & RX_COMPLETE)
   {
		Block_Read(In_Packet, sizeof(In_Packet));

		switch (In_Packet[0])
		{
		default:;
   		}
	}

   if (INTVAL & DEV_SUSPEND)
   {
        Suspend_Device();
   }

   if (INTVAL & DEV_CONFIGURED)
   {
//      Initialize();
   }
}

//
//
//
//

//;=============================================================================================
//; ВРЕМЕННЫЕ ЗАДЕРЖКИ
//;
// 1 мкс = 24 такта
//; Формула: 8+(2+((R0-1)*3)+2)+(2+(((R2-1)*3)+2))+9
//; Данные:  R0 = 140, R0=79
//;          R1 = 253
//; Итого:   8+(2+((140-1)*3)+2)+(2+(((253-1)*3)+2)+(2+(((79-1)*3)+2))+2+9 = 1440
//;---------------------------------------------------------------------------------------------
/*
void Del_10mks(void)
{
	#pragma asm
	push	00h							; 2 такта             | 6 тактов
	mov   R0,#75						; 2 такта             |
	djnz  R0,$							; (74*3)+2=224 такта  | 227 тактов
	nop									; 1 такт              |
	
	pop	00h							; 2 такта             | 7 тактов
	ret									; Возврат 5 тактов    |
	#pragma endasm
}

void Del_500mks(void)
{
	#pragma asm
	push	00h							; 2 такта             |
	push	01h							; 2 такта             |
	push	02h							; 2 такта             | 12 тактов
											;                     |
	mov   R1,#20						; 2 такта             |
		
	mov   R0,#195						; 2 такта             | (589*20)-1=
	djnz  R0,$							; (194*3)+2=584 такта | 11779 тактов
	djnz	R1,$-4						; 3 такта             |

	mov   R2,#65						; 2 такта             |
	djnz  R2,$							; (64*3)+2=194 тактов | 198 тактов
	nop									; 1 такт              |
	nop									; 1 такт              |
						
	pop	02h							; 2 такта             |
	pop	01h							; 2 такта             | 11 тактов
	pop	00h							; 2 такта             |
	ret									; Возврат 5 тактов    |
	#pragma endasm
}

void Del_10ms(void)
{
	#pragma asm
	push	00h							; 2 такта             |
	push	01h							; 2 такта             |
	push	02h							; 2 такта             | 14 тактов
	push	03h							; 2 такта             |
																;                     |
	mov   R2,#6							; 2 такта             |					
									
	mov   R1,#168	;              | 2 такта +           |
	mov   R0,#78	; 2 такта +    |                     | (39988*6)-1=
	djnz	R0,$		; (77*3)+2=233 | (((235+3)*168)-1)=  | 239927 тактов
	djnz  R1,$-4	;              |    55249 тактов     |   
	djnz	R2,$-8	;              | + 3 такта           |

	mov   R3,#15						; 2 такта             |
	djnz  R3,$							; (14*3)+2=44 тактов  | 46 тактов
						
	pop	03h							; 2 такта             |
	pop	02h							; 2 такта             |
	pop	01h							; 2 такта             | 13 тактов
	pop	00h							; 2 такта             |
	ret									; Возврат 5 тактов    |
	#pragma endasm
}

void Del_25ms(void)
{
	#pragma asm
	push	00h							; 2 такта             |
	push	01h							; 2 такта             |
	push	02h							; 2 такта             | 14 тактов
	push	03h							; 2 такта             |
																;                     |
	mov   R2,#15						; 2 такта             |					
					
	mov   R1,#168	;              | 2 такта +           |
	mov   R0,#78	; 2 такта +    |                     | (39988*15)-1=
	djnz	R0,$		; (77*3)+2=233 | (((235+3)*168)-1)=  | 599819 тактов
	djnz  R1,$-4	;              |    55249 тактов     |   
	djnz	R2,$-8	;              | + 3 такта           |

	mov   R3,#51						; 2 такта             |
	djnz  R3,$							; (50*3)+2=152 тактов | 154 тактов
						
	pop	03h							; 2 такта             |
	pop	02h							; 2 такта             |
	pop	01h							; 2 такта             | 13 тактов
	pop	00h							; 2 такта             |
	ret									; Возврат 5 тактов    |
	#pragma endasm
}

void Del_100ms(void)
{
	#pragma asm
	push	00h							; 2 такта             |
	push	01h							; 2 такта             |
	push	02h							; 2 такта             | 14 тактов
	push	03h							; 2 такта             |
											;                     |
	mov   R2,#60						; 2 такта             |					
								
	mov   R1,#168	;              | 2 такта +           |
	mov   R0,#78	; 2 такта +    |                     | (39988*60)-1=
	djnz	R0,$		; (77*3)+2=233 | (((235+3)*168)-1)=  | 2399279 тактов
	djnz  R1,$-4	;              |    55249 тактов     |   
	djnz	R2,$-8	;              | + 3 такта           |

	mov   R3,#231						; 2 такта             |
	djnz  R3,$							; (230*3)+2=692 тактов| 694 тактов
	
	pop	03h							; 2 такта             |
	pop	02h							; 2 такта             |
	pop	01h							; 2 такта             | 13 тактов
	pop	00h							; 2 такта             |
	ret									; Возврат 5 тактов    |
	#pragma endasm
}
*/

void Del(int a)
{
	int i;
	for (i=0;i<a;i++)
	{
	}
}

